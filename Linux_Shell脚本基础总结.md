# Linux_Shell脚本基础 #


1.	查看Linux对shell的支持
	
	`/etc/shells` 文件记录了当前Linux系统支持的shell类型
2. shell 脚本的第一行

	```bash
		#!bin/bash
	```
   因为在linux中，文件名并不能标识当前的文本是什么东西(在windows下可以通过后缀来标识)，因此我们往往通过在文本的第一行添加#!/bin/bash来标识这个文件是shell脚本

3.  除了第一行之外，shell脚本中所有以#开头的行都会被视为注释



4. shell重定向

	
	1. linux中只有3个输入输出设备：

		标准输入（键盘，没有鼠标）-0，标准输出（显示屏）-1，标准错误输出（显示屏）-2
 
	2. 将一个命令的输出重定向到一个文件中:
	
		```bash
			ls > fileName 2>&1 
			ls &> fileName
		```

5. linux中的命令批量执行

	- 	cmd1;cmd2;cmd3  : 这3个命令之间没有任何联系，操作系统只会顺序执行命令1,2,3;不管其对错，如果其中一个命令错误，其他的命令也会执行，相当于把几个需要手动敲的命令，一下全部放在一起

	- cmd1 && cmd2    :逻辑与，在linux中为提高执行效率，采取判断逻辑的最简单原则：cmd1错误，则整个与表达式false,不会执行cmd2;只有当cmd1正确时才会执行cmd2

	- cmd1 || cmd2   : 逻辑或，为提高执行效率，当cmd1为 true时，整个表达式为true, 这时就不会执行cmd2;只有当cmd1为false时，才会去执行cmd2

	注意：其具体实现，怎么知道前一个命令是否正确执行，实际上是通过：$? 来查询上一条指令的返回值是否是0，如果返回0，表示正确执行

6. linux中的管道符：

	将一个命令的输出作为另一个命令的输入

7. linux中的通配符：

	？ 匹配一个字符（不能匹配0个字符）

	 *匹配任意0个或多个字符

	[123] : 匹配中括号中的任意一个字符

	[1-9],[a-z].[A-Z],匹配一个范围

	[^1-9],[^a-z]:匹配不是中括号中的任意一个字符

	可以用ls + 【正则】 来匹配自己想列出的文件

8. linux中的特殊字符:

	linux中：
	单引号： '  '      表示其中的所有字符都按普通字符处理;
	双引号: "  $ , `` ,  \ " 都有特殊含义
	
	```bash

		name = guoqingpei
		$name    # 引用变量name的值： echo '$name'-> $name     ;    
		echo "$name" ->guoqingpei
		name = $(pwd)  将系统命令的返回作为当前变量name的值
		举个例子：
		pwd = /
		echo pwd ->pwd
		echo $PWD -> /
		echo '$PWD' -> $PWD
		echo "$PWD" -> /
		echo "\$PWD" ->$PWD
		echo '\$PWD' -> \$PWD
		echo "$(ls)" 执行系统命令之后返回结果
	```

	注意：在命令行中加不加双引号，的区别仅在于有空格时双引号会连同空格把引号里面的当做整体来对待，而双引号和单引号的差距非常大
	单引号仅表示字面含义，简简单单的字符串

9. linux的环境变量：

	1）注意：直接用 name=guoqingpei 在shell中申明的变量为临时的变量，在其子shell和其他shell中都不会保存,只有把它变成环境变量(`export name=guoqingpei`)，才能在其他shell中生效,如果想让其在关机后仍然生效，则必须将其写入配置文件，每次开机都会读取

	2)两个非常重要的环境变量：
	$PATH,$PS1
	PATH:变量用来修改系统命令的搜索路径，注意：在linux中，所有文件要执行必须：1）添加执行权限 2）调用时用相对路径或绝对路径的指定文件的位置;
	像 ls , mount , ps 等系统命令之所以不用指明路径，是因为他们的路径在PATH中保存;

	同样，如果我们自己写了个命令，想被当作和系统命令一样调用，不用每次调用的时候都输入路径名，这时就把自己写的命令的目录加入到系统的搜索路径当中去：
	`PATH=$PATH:/home/guoqingpei`       注意:PATH之中的路径名都是用“：”分隔的

	$PS1  变量用来定制自己系统的提示(系统自带的已经很好了，没有特殊需求不建议修改)

10. linux Shell的位置参数变量

	位置参数变量是用户向shell脚本传参的途径，之所以叫位置参数变量，是因为shell脚本中是按参数位置来提取用户输入的参数的.

	linux中位置参数变量只有4个:

	- $n: 第0个参数是命令本身，用户传入的第1个参数是$1,第2个参数是$2,依次类推。。。。
	- $#:用户传入所有参数的个数，不包括命令本身(命令本身不是参数）
	- $*:将用户传入的所有参数都当作一个字符串看待
	- $@:将用户传入的所有参数都放在一个保存参数的列表中

	另:
	$$:当前进程号;
	$!:后台运行的最后一个进程号

11. linux中接受键盘输入

	read命令：
	```bash
		read -s -n 10  -t 30 -p "input name: "  name 
		-s:secret:表示用户输入时不显示
		-n:表示接受多少个字符后自动停止接收字符，如果超时，给name变量赋值为空
		-t:表示等待用户输入的时间
		-p:prompt提示，表示告诉用户当前要输入什么
		name ： 表示保存用户输入的变量名
	```


12. linux中进行数值运算:

	`$((  $var1 + $var2 / $var3 %3      ))`-双括号之间可以放任何的表达式

13. Shell中的变量测试：
	在shell中，可以写类似于：
	`x=${y-new}` 来测试y变量是否存在，如果y不存在，则x=new ,否则 x=$y

	大概了解下，类似于正则表达式一样比较复杂，晦涩难懂，用到的时候直接去查

14. ubuntu 修改远程和本地登陆的提示信息:


```bash

	1)/var/run/motd.dynamic
	#直接修改里面的文本就可以实时修改登录信息
	#不管是本地登录，还是远程登陆的信息都可以修改
	2)/etc/ssh/sshd.config  ssh 的配置文件
	3)ubuntu的环境变量的配置文件:
	系统启动时，依次读取:
	/etc/profile -> /etc/environment -> /etc/bash.bashrc -> ~/.profile    ->  ~/.bashrc
	在这几个文件中，我们都可以添加自己的环境变量从而保证系统在每次启动时都会读取我们设置的环境变量，进而永久生效
	推荐：
	对于全部用户生效：/etc/environment
	只对当前用户生效:  ~/.bashrc
	
	注意：每当对配置文件进行修改，要使其立即生效，必须用：
	source configfile  或者 . configfile
	注意：
	source 命令 与 执行一个shell脚本的区别：
	当我们直接用一个路径去掉shell脚本时，我们往往想要的是shell脚本的执行结果，这时系统会为shell脚本另开一个进程空间，当程序执行完后清除所有的中间变量，并将结果返回
	但我们用source命令时，系统会直接在当前进程中执行shell脚本，shell脚本中的变量全部都在系统当前本地变量中保存，执行完后也不会释放。
	
	因此，与环境变量有关的脚本，往往是在计算环境变量的值，然后我们用source执行，将它放入当前环境变量中
	而普通的shell脚本往往是在执行某个计算任务，我们只需最后结果，因此不必放到当前环境中
	
	注意： source 和 路径执行 都能执行脚本，关键区别在于我们想不想保存中间变量
	
	env 命令 可以查看所有的环境变量
	set 命令 可以查看所有的本地变量和环境变量 
```





